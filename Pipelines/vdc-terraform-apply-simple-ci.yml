# This pipeline perfors a full CI test of the VDC:
#  - Provision infrastructure
#  - Destroy infrastructure

parameters:
- name: debug
  displayName: Debug
  type: boolean
  default: false
- name: provision
  displayName: Provision infrastructure
  type: boolean
  default: true
- name: destroy
  displayName: Destroy infrastructure
  type: boolean
  default: true

trigger:
  batch: true
  branches:
    include:
    - master
  paths:
    include:
    - 'Scripts/*' 
    - 'Terraform/*' 
    exclude:
    - 'Apps/*'
    - 'Kusto/*'
    - 'Pipelines/*'

pr:
  branches:
    include:
    - '*'

schedules:
  - cron: '0 2 * * *'
    displayName: 'Daily early morning build (UTC)'
    # Run if there are no changes
    always: 'true'
    branches:
      include:
      - master

# Global variables shared by all jobs
variables:
- name: 'TF_IN_AUTOMATION'
  value: 'true'
- name: 'TF_INPUT'
  value: 0

# Inline variables shared across jobs
- name: 'jobTimeOutMinutes'
  value: 120
- name: 'scriptDirectory'
  value: '$(Build.SourcesDirectory)/Scripts'
- name: 'terraformDirectory'
  value: '$(Build.SourcesDirectory)/Terraform'
- name: 'system.debug'
  value: ${{ parameters.debug }}

jobs:
- job: 'Prepare'
  displayName: 'Prepare'
  condition: succeeded()
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  pool:
    vmImage: 'ubuntu-latest'

  workspace:
    clean: all

  steps:
    - task: AzureCLI@2
      displayName: 'Gather Terraform settings'
      name: terraformConfig
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          # List environment variables (debug)
          if ((${env:system.debug} -eq "true") -or ($env:system_debug -eq "true") -or ($env:SYSTEM_DEBUG -eq "true")) {
            Get-ChildItem -Path Env:ARM_* | Sort-Object -Property Name
          }

          # This will write version info as output variable
          $(scriptDirectory)/get_tf_version.ps1 -version preferred
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(scriptDirectory)'

- ${{ if eq(parameters.provision, true) }}:
  # Provision on self-hosted agent
  - job: 'Provision'
    dependsOn: Prepare
    displayName: 'Provision Infrastructure with Terraform'
    condition: succeeded()
    timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

    variables:
      # Use earlier prepared Terraform config
      terraformClientId: $[ dependencies.Prepare.outputs['terraformConfig.clientId'] ]
      terraformClientSecret: $[ dependencies.Prepare.outputs['terraformConfig.clientSecret'] ]
      terraformSubscriptionId: $[ dependencies.Prepare.outputs['terraformConfig.subscriptionId'] ]
      terraformTenantId: $[ dependencies.Prepare.outputs['terraformConfig.tenantId'] ]
      terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

    pool:
      vmImage: 'ubuntu-latest'

    workspace:
      clean: all

    steps:
      # We could do this with tfenv, however there is no task for that
      - task: TerraformInstaller@0
        displayName: 'Use preferred Terraform version'
        inputs:
          terraformVersion: '$(terraformVersion)'

      - task: AzureCLI@2
        name: terraform
        displayName: 'Terraform init & apply'
        enabled: true
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          # ARM_* environment variables are required by Terraform azurerm provider and backend
          # https://www.terraform.io/docs/providers/azurerm/index.html
          # https://www.terraform.io/docs/backends/types/azurerm.html
          # Use Pipeline Service Principal and Service Connection to set up these variables
          inlineScript: |
            $env:ARM_CLIENT_ID=$env:servicePrincipalId
            $env:ARM_CLIENT_SECRET=$env:servicePrincipalKey
            $env:ARM_SUBSCRIPTION_ID=$(az account show --query id) -replace '"',''
            $env:ARM_TENANT_ID=$env:tenantId
            terraform init
            terraform apply -auto-approve
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'
        env:
          TF_VAR_default_create_timeout: '$(jobTimeOutMinutes)m'

- ${{ if eq(parameters.destroy, true) }}:
  # Destroy infrastructure
  - job: 'Destroy'
    dependsOn:
      - Prepare
      - ${{ if eq(parameters.provision, true) }}:
        - Provision
    displayName: 'Destroy Infrastructure with Terraform'
    condition: succeededOrFailed()
    timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

    variables:
      # Use earlier prepared Terraform config
      terraformClientId: $[ dependencies.Prepare.outputs['terraformConfig.clientId'] ]
      terraformClientSecret: $[ dependencies.Prepare.outputs['terraformConfig.clientSecret'] ]
      terraformSubscriptionId: $[ dependencies.Prepare.outputs['terraformConfig.subscriptionId'] ]
      terraformTenantId: $[ dependencies.Prepare.outputs['terraformConfig.tenantId'] ]
      terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

    pool:
      vmImage: 'ubuntu-latest'

    steps:
      # Assume workspace is empty and re-download secure files
      - task: TerraformInstaller@0
        displayName: 'Use preferred Terraform version'
        inputs:
          terraformVersion: '$(terraformVersion)'

      - task: AzureCLI@2
        name: terraformConfig
        displayName: 'Terraform destroy'
        condition: succeededOrFailed()
        enabled: true
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          # ARM_* environment variables are required by Terraform azurerm provider and backend
          # https://www.terraform.io/docs/providers/azurerm/index.html
          # https://www.terraform.io/docs/backends/types/azurerm.html
          # Use Pipeline Service Principal and Service Connection to set up these variables
          inlineScript: |
            $env:ARM_CLIENT_ID=$env:servicePrincipalId
            $env:ARM_CLIENT_SECRET=$env:servicePrincipalKey
            $env:ARM_SUBSCRIPTION_ID=$(az account show --query id) -replace '"',''
            $env:ARM_TENANT_ID=$env:tenantId

            terraform init
            terraform destroy -auto-approve
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'
        env:
          TF_VAR_default_create_timeout: '$(jobTimeOutMinutes)m'

      # When using tfenv, this will make sure the same Terraform version will be used as we tested in this pipeline
      - task: PowerShell@2
        displayName: 'Save used Terraform version number with tfenv'
        inputs:
          targetType: filePath
          filePath: '$(scriptDirectory)/get_tf_version.ps1'
          arguments: ' -version installed | Out-File $(Build.SourcesDirectory)/Terraform/.terraform-version'
          pwsh: true
          workingDirectory: '$(scriptDirectory)'

      # Publish Initialized Terraform workspace
      # This workspace can be downloaded as artifacts in a release pipeline. 
      # That release pipeline will than run with tested versions of Terraform and Terraform providers, without the need for 'terraform init'
      - task: PublishPipelineArtifact@1
        displayName: 'Publish Initialized Terraform workspace'
        inputs:
          artifact: drop

- ${{ if eq(parameters.destroy, true) }}:
  # Clean up resources, in the event 'terraform destroy' fails   
  - job: 'CleanUp'
    dependsOn:
      - Prepare
      - Destroy
    displayName: 'Clean Up'
    # Run if Terraform provision or destroy failed, or the whole pipeline was canceled
    condition: or(ne(dependencies.Provision.result, 'Succeeded'), ne(dependencies.Destroy.result, 'Succeeded'), canceled())
    timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

    variables:
      # Use earlier prepared Terraform config
      terraformClientId: $[ dependencies.Prepare.outputs['terraformConfig.clientId'] ]
      terraformClientSecret: $[ dependencies.Prepare.outputs['terraformConfig.clientSecret'] ]
      terraformSubscriptionId: $[ dependencies.Prepare.outputs['terraformConfig.subscriptionId'] ]
      terraformTenantId: $[ dependencies.Prepare.outputs['terraformConfig.tenantId'] ]
      terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

    pool:
      vmImage: 'ubuntu-latest'

    workspace:
      clean: all

    steps:
      # Clear Terraform workspace, just in case
      # As a last resort, this also destroys any resources that may not have deleted before
      - task: AzureCLI@2
        name: terraformConfig
        displayName: 'Clear Terraform workspace'
        condition: succeededOrFailed()
        enabled: true
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            $env:ARM_CLIENT_ID=$env:servicePrincipalId
            $env:ARM_CLIENT_SECRET=$env:servicePrincipalKey
            $env:ARM_SUBSCRIPTION_ID=$(az account show --query id) -replace '"',''
            $env:ARM_TENANT_ID=$env:tenantId

            terraform init
            $(scriptDirectory)/tf_clear_state.ps1 -environment dflt -destroy -force -wait -timeoutminutes $(jobTimeOutMinutes)
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'
          