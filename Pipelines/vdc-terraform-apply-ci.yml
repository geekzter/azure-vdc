# This pipeline perfors a full CI test of the VDC:
#  - Provision infrastructure
#  - Deploy application
#  - Test application
#  - Destroy infrastructure

trigger:
  batch: true
  branches:
    include:
    - master
  paths:
    include:
    - 'Scripts/*' 
    - 'Terraform/*' 
    exclude:
    - 'Apps/*'
    - 'Kusto/*'
    - 'Pipelines/*'

pr:
  branches:
    include:
    - '*'

schedules:
  - cron: '0 4 * * *'
    displayName: 'Daily early morning build (UTC)'
    # Run if there are no changes
    always: 'true'
    branches:
      include:
      - master

# Global variables shared by all jobs
variables:
  # Variable Groups are referenced, but defined elsewhere (Library)

  # This pipeline assumes TF_VAR_* variables are defined in Variable Groups defined in Library
  # The Terraform VDC project requires quite a number of settings, see:
  # https://github.com/geekzter/azure-vdc/blob/master/Terraform/variables.tf
  # https://github.com/geekzter/azure-vdc/blob/master/Terraform/config.auto.tfvars.sample
  # https://github.com/geekzter/azure-vdc/blob/master/Terraform/ci.tfvars
  # i.e. settings in these files should be captured in (a) variable group(s)
  # These can be provided as TF_VAR_<input-variable> environment variables:
  # https://www.terraform.io/docs/configuration/variables.html#environment-variables
  # 'vdc' contains global settings common to all VDC pipelines
- group: 'vdc'
  # 'vdc-ci' contains build (non-release) settings
- group: 'vdc-ci'
  # 'vdc-vanity-domain' contains certificate, domain information
- group: 'vdc-vanity-domain'

- name: 'ARM_PROVIDER_STRICT'
  value: 'true'
- name: 'TF_IN_AUTOMATION'
  value: 'true'
- name: 'TF_INPUT'
  value: 0
- name: 'TF_WORKSPACE'
  value: 'ci'

# Inline variables shared across jobs
  # This references this pipeline:
  # https://github.com/geekzter/dotnetcore-sqldb-tutorial/blob/master/azure-pipelines.yml
- name: 'appPipeline'
  value: '0b7ba88e-1ad0-4782-839e-850e9a4b53c7'
- name: 'jobTimeOutMinutes'
  value: 120
- name: 'scriptDirectory'
  value: '$(Build.SourcesDirectory)/Scripts'
- name: 'iaasResourceGroup'
  value: '$(TF_VAR_resource_prefix)-$(TF_VAR_resource_environment)-iaasapp-$(TF_VAR_resource_suffix)'
- name: 'paasResourceGroup'
  value: '$(TF_VAR_resource_prefix)-$(TF_VAR_resource_environment)-paasapp-$(TF_VAR_resource_suffix)'
- name: 'vdcResourceGroup' 
  value: '$(TF_VAR_resource_prefix)-$(TF_VAR_resource_environment)-$(TF_VAR_resource_suffix)'


jobs:
# Provision on self-hosted agent
- job: 'Provision'
  displayName: 'Provision Infrastructure with Terraform'
  condition: succeeded()
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  pool:
    vmImage: 'ubuntu-latest'

  workspace:
    clean: all

  steps:
    - task: DownloadSecureFile@1
      displayName: 'Download SSL certificate'
      inputs:
        secureFile: '$(TF_VAR_vanity_certificate_path)'

    - task: DownloadSecureFile@1
      displayName: 'Download VPN root certificate'
      inputs:
        secureFile: '$(TF_VAR_vpn_root_cert_file)'

    - task: AzureCLI@2
      displayName: 'Gather Terraform settings'
      name: terraformConfig
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        # ARM_* environment variables are required by Terraform azurerm provider and backend
        # https://www.terraform.io/docs/providers/azurerm/index.html
        # https://www.terraform.io/docs/backends/types/azurerm.html
        # Use Pipeline Service Principal and Service Connection to set up these variables
        inlineScript: |
          $env:ARM_CLIENT_ID=$env:servicePrincipalId
          $env:ARM_CLIENT_SECRET=$env:servicePrincipalKey
          $env:ARM_SUBSCRIPTION_ID=$(az account show --query id) -replace '"',''
          $env:ARM_TENANT_ID=$env:tenantId
          # List environment variables (debug)
          if ((${env:system.debug} -eq "true") -or ($env:system_debug -eq "true") -or ($env:SYSTEM_DEBUG -eq "true")) {
            Get-ChildItem -Path Env:ARM_* | Sort-Object -Property Name
          }
          Write-Host "##vso[task.setvariable variable=clientId;isOutput=true]$env:ARM_CLIENT_ID"
          Write-Host "##vso[task.setvariable variable=clientSecret;isOutput=true]$env:ARM_CLIENT_SECRET"
          Write-Host "##vso[task.setvariable variable=subscriptionId;isOutput=true]$env:ARM_SUBSCRIPTION_ID"
          Write-Host "##vso[task.setvariable variable=tenantId;isOutput=true]$env:ARM_TENANT_ID"

          # This will write version info as output variable
          $(scriptDirectory)/get_tf_version.ps1 -version preferred
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(scriptDirectory)'

    # We could do this with tfenv, however there is no task for that
    - task: TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformConfig.version)'

    - task: AzurePowerShell@4
      # Name is required so Terraform output exported by tf_deploy.ps1 can be referenced by subsequent Pipeline steps
      name: terraform
      displayName: 'Terraform init & apply'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        ScriptType: 'FilePath'
        # tf_deploy.ps1 is a wrapper around, and invokes, Terraform
        ScriptPath: '$(scriptDirectory)/tf_deploy.ps1'
        # To start from scratch, use these arguments:
        ScriptArguments: '-init -clear -apply -force -trace $(trace) -parallelism $(parallelism)'
        # To continue where a previous (broken) build left of, use these arguments:
      # ScriptArguments: '-init -apply -force -stickysuffix -trace $(trace) -parallelism $(parallelism)'
        FailOnStandardError: true
        azurePowerShellVersion: 'LatestVersion'
        pwsh: true
        workingDirectory: '$(scriptDirectory)'
      env:
        # Use prepared Terraform environment variables
        ARM_CLIENT_ID: '$(terraformConfig.clientId)'
        ARM_CLIENT_SECRET: '$(terraformConfig.clientSecret)'
        ARM_SUBSCRIPTION_ID: '$(terraformConfig.subscriptionId)'
        ARM_TENANT_ID: '$(terraformConfig.tenantId)'
        TF_VAR_default_create_timeout: '$(jobTimeOutMinutes)m'


# Provision again to test for issue's that only come up when resources already exist 
- job: 'Reprovision'
  dependsOn: 'Provision'
  displayName: 'Provision Infrastructure with Terraform (re-entrance test)'
  condition: succeeded()
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  variables:
    # Use earlier prepared Terraform config
    terraformClientId: $[ dependencies.Provision.outputs['terraformConfig.clientId'] ]
    terraformClientSecret: $[ dependencies.Provision.outputs['terraformConfig.clientSecret'] ]
    terraformSubscriptionId: $[ dependencies.Provision.outputs['terraformConfig.subscriptionId'] ]
    terraformTenantId: $[ dependencies.Provision.outputs['terraformConfig.tenantId'] ]
    terraformVersion: $[ dependencies.Provision.outputs['terraformConfig.version'] ]

  pool:
    vmImage: 'ubuntu-latest'

  steps:
    # Assume workspace is empty and re-download secure files
    - task: DownloadSecureFile@1
      displayName: 'Download SSL certificate'
      inputs:
        secureFile: '$(TF_VAR_vanity_certificate_path)'

    - task: DownloadSecureFile@1
      displayName: 'Download VPN root certificate'
      inputs:
        secureFile: '$(TF_VAR_vpn_root_cert_file)'

    - task: TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformVersion)'

    # Deallocate/Stop MV's to force tf_deploy.ps1 to test for stopped VM's
    # Stopped VM's do not allow extensions to be installed
    - task: AzureResourceGroupDeployment@2
      displayName: 'Deallocate VM''s in App resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: StopWithDeallocate
        resourceGroupName: '$(iaasResourceGroup)'

    - task: AzureResourceGroupDeployment@2
      displayName: 'Stop VM''s in VDC resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: Stop
        resourceGroupName: '$(vdcResourceGroup)'

    # Test for failures that only occur when resources already exist
    - task: AzurePowerShell@4
      # Name is required so Terraform output exported by tf_deploy.ps1 can be referenced by subsequent Pipeline steps
      name: terraform
      displayName: 'Terraform init and apply (re-entrance test)'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        ScriptType: 'FilePath'
        # tf_deploy.ps1 is a wrapper around, and invokes, Terraform
        ScriptPath: '$(scriptDirectory)/tf_deploy.ps1'
        ScriptArguments: '-init -apply -force -stickysuffix -trace $(trace) -parallelism $(parallelism)'
        FailOnStandardError: true
        azurePowerShellVersion: 'LatestVersion'
        pwsh: true
        workingDirectory: '$(scriptDirectory)'
      env:
        # Use prepared Terraform environment variables
        ARM_CLIENT_ID: '$(terraformClientId)'
        ARM_CLIENT_SECRET: '$(terraformClientSecret)'
        ARM_SUBSCRIPTION_ID: '$(terraformSubscriptionId)'
        ARM_TENANT_ID: '$(terraformTenantId)'
        TF_VAR_default_create_timeout: '$(jobTimeOutMinutes)m'

        
# Deploy PaaS application 
- job: 'Deploy'
  dependsOn:
    - Reprovision
  displayName: 'Deploy & Test PaaS Application'
  condition: succeeded()
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  variables:
    appArtifactDirectory: '$(Pipeline.Workspace)/aspnetcoresql'
    appBuild: 'Release'
    appPackage: '$(appArtifactDirectory)/s/bin/$(appBuild)/netcoreapp2.2/publish.zip'
    # Get application configuration from Terraform output
    appServiceName: $[ dependencies.Reprovision.outputs['terraform.paas_app_service_name'] ]
    appUrl: $[ dependencies.Reprovision.outputs['terraform.paas_app_url'] ]
    appMSIName: $[ dependencies.Reprovision.outputs['terraform.paas_app_service_msi_name'] ]
    appMSIClientID: $[ dependencies.Reprovision.outputs['terraform.paas_app_service_msi_client_id'] ]
    appSQLAdmin: 'vdcadmin'
    appSQLDatabase: $[ dependencies.Reprovision.outputs['terraform.paas_app_sql_database'] ]
    appSQLFirewallImportRule: 'AllowAllWindowsAzureIPs'
    appSQLServer: $[ dependencies.Reprovision.outputs['terraform.paas_app_sql_server'] ]
    appSQLServerFQDN: $[ dependencies.Reprovision.outputs['terraform.paas_app_sql_server_fqdn'] ]
    storageUrl: 'https://ewimages.blob.core.windows.net/databasetemplates/vdcdevpaasappsqldb-2020-1-18-15-13.bacpac'
    storageSAS: '?st=2020-03-20T13%3A57%3A32Z&se=2023-04-12T13%3A57%3A00Z&sp=r&sv=2018-03-28&sr=c&sig=qGpAjJlpDQsq2SB6ev27VbwOtgCwh2qu2l3G8kYX4rU%3D'

  pool:
    vmImage: 'ubuntu-latest'

  steps:
    - task: AzureCLI@2
      displayName: 'Open SQL Firewall for import'
      enabled: true
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          # Create SQL Firewall rule for import
          Write-Host "az sql server firewall-rule show -g $(paasResourceGroup) -s $(appSQLServer) -n $(appSQLFirewallImportRule)"
          $sqlFWRule = $(az sql server firewall-rule show -g $(paasResourceGroup) -s $(appSQLServer) -n $(appSQLFirewallImportRule) 2>$null)
          if (!$sqlFWRule) {
              Write-Host "Creating SQL Server $(appSQLServer) Firewall rule '$(appSQLFirewallImportRule)' ..."
              $sqlFWRule = $(az sql server firewall-rule create -g $(paasResourceGroup) -s $(appSQLServer) -n $(appSQLFirewallImportRule) --start-ip-address 0.0.0.0 --end-ip-address 0.0.0.0)
          } else {
              Write-Host "SQL Server $(appSQLServer) Firewall rule $(appSQLFirewallImportRule) already exists"
          }
        useGlobalConfig: true
        workingDirectory: '$(scriptDirectory)'
        failOnStandardError: false

    - task: AzureCLI@2
      displayName: 'Import database'
      enabled: true
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          # Create temporary admin password
          #Write-Host "Database $(appSQLServer): resetting admin password"
          #$password = New-Guid | Select-Object -ExpandProperty Guid
          #az sql server update --admin-password $password --resource-group $(paasResourceGroup) --name $(appSQLServer)

          # Perform import          
          Write-Host "Database $(appSQLServer)/$(appSQLDatabase): importing from $(storageUrl)..."
          az sql db import -s $(appSQLServer) -n $(appSQLDatabase) -g $(paasResourceGroup) `
                           --auth-type ADPassword -u $env:servicePrincipalId -p $env:servicePrincipalKey `
                           --storage-key $(storageSAS) --storage-key-type SharedAccessKey --storage-uri $(storageUrl)
        addSpnToEnvironment: true
        useGlobalConfig: true
        workingDirectory: '$(scriptDirectory)'
        failOnStandardError: true

    - task: AzureCLI@2
      displayName: 'Grant App Service MSI access to database'
      enabled: true
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          # Grant access to App Service MSI
          # This uses the Terraform/Pipeline Service Principal identity
          ./grant_database_access.ps1 -MSIName $(appMSIName) -MSIClientId $(appMSIClientID) `
                                      -DBAName Automation -DBAObjectId $env:servicePrincipalId `
                                      -SqlDatabaseName $(appSQLDatabase) -SqlServerFQDN $(appSQLServerFQDN)
        addSpnToEnvironment: true
        useGlobalConfig: true
        workingDirectory: '$(scriptDirectory)'
        failOnStandardError: true

    - task: AzureCLI@2
      displayName: 'Remove SQL Firewall import rule'
      enabled: true
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          # Remove SQL Firewall rule
          Write-Host "Removing SQL Server $(appSQLServer) Firewall rule $sqlFWRuleName ..."
          az sql server firewall-rule delete -g $(paasResourceGroup) -s $(appSQLServer) -n $(appSQLFirewallImportRule)
        useGlobalConfig: true
        workingDirectory: '$(scriptDirectory)'
        failOnStandardError: true

    # Download PaaS Application Pipeline artifacts
    # This consumes artifacts published by this pipeline:
    # https://github.com/geekzter/dotnetcore-sqldb-tutorial/blob/master/azure-pipelines.yml
    - task: DownloadPipelineArtifact@2
      displayName: 'Download ASP.NET Core App Artifacts'
      inputs:
        buildType: 'specific'
        project: '$(appPipeline)'
        definition: '63'
        specificBuildWithTriggering: true
        buildVersionToDownload: 'latest'
        artifactName: 'aspnetcoresql'
        targetPath: '$(appArtifactDirectory)'

    - task: PowerShell@2
      displayName: 'List ASP.NET Core App Artifacts'
      enabled: false # Used for debug only, e.g. if the publish.zip package got moved
      inputs:
        targetType: 'inline'
        script: 'Get-ChildItem . -Recurse | Select-Object FullName'
        errorActionPreference: 'continue'
        pwsh: true
        workingDirectory: '$(appArtifactDirectory)'

    # Deploy PaaS Application
    - task: AzureWebApp@1
      displayName: 'Deploy ASP.NET Core App'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        appType: webApp
        appName: '$(appServiceName)'
        package: '$(appPackage)'

    # Test PaaS Application
    - task: PowerShell@2
      displayName: 'Test ASP.NET Core App'
      inputs:
        targetType: 'inline'
        script: |
          # Wait for the WAF to get ready
          Start-Sleep -Seconds 30
          
          # Request page
          Invoke-WebRequest $(appUrl)
        failOnStderr: true
        pwsh: true


# Destroy infrastructure
- job: 'Destroy'
  dependsOn:
    - Deploy
    - Provision
  displayName: 'Destroy Infrastructure with Terraform'
  condition: succeededOrFailed()
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  variables:
    # Use earlier prepared Terraform config
    terraformClientId: $[ dependencies.Provision.outputs['terraformConfig.clientId'] ]
    terraformClientSecret: $[ dependencies.Provision.outputs['terraformConfig.clientSecret'] ]
    terraformSubscriptionId: $[ dependencies.Provision.outputs['terraformConfig.subscriptionId'] ]
    terraformTenantId: $[ dependencies.Provision.outputs['terraformConfig.tenantId'] ]
    terraformVersion: $[ dependencies.Provision.outputs['terraformConfig.version'] ]

  pool:
    vmImage: 'ubuntu-latest'

  steps:
    # Assume workspace is empty and re-download secure files
    - task: DownloadSecureFile@1
      displayName: 'Download SSL certificate'
      inputs:
        secureFile: '$(TF_VAR_vanity_certificate_path)'

    - task: DownloadSecureFile@1
      displayName: 'Download VPN root certificate'
      inputs:
        secureFile: '$(TF_VAR_vpn_root_cert_file)'
        
    - task: TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformVersion)'

    # Terraform will destroy all resources it created, using its backend state
    - task: AzurePowerShell@4
      displayName: 'Terraform destroy'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        # tf_deploy.ps1 is a wrapper around, and invokes, Terraform
        ScriptPath: '$(scriptDirectory)/tf_deploy.ps1'
        ScriptArguments: '-init -destroy -force -trace $(trace) -parallelism $(parallelism)'
        FailOnStandardError: true
        azurePowerShellVersion: LatestVersion
        pwsh: true
        workingDirectory: '$(scriptDirectory)'
      condition: succeededOrFailed()
      enabled: true
      env:
        # Use prepared Terraform environment variables
        ARM_CLIENT_ID: '$(terraformClientId)'
        ARM_CLIENT_SECRET: '$(terraformClientSecret)'
        ARM_SUBSCRIPTION_ID: '$(terraformSubscriptionId)'
        ARM_TENANT_ID: '$(terraformTenantId)'
        TF_VAR_default_delete_timeout: '$(jobTimeOutMinutes)m'

    # When using tfenv, this will make sure the same Terraform version will be used as we tested in this pipeline
    - task: PowerShell@2
      displayName: 'Save used Terraform version number with tfenv'
      inputs:
        targetType: filePath
        filePath: '$(scriptDirectory)/get_tf_version.ps1'
        arguments: ' -version installed | Out-File $(Build.SourcesDirectory)/Terraform/.terraform-version'
        pwsh: true
        workingDirectory: '$(scriptDirectory)'

    # Publish Initialized Terraform workspace
    # This workspace can be downloaded as artifacts in a release pipeline. 
    # That release pipeline will than run with tested versions of Terraform and Terraform providers, without the need for 'terraform init'
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Initialized Terraform workspace'
      inputs:
        artifact: drop


# Clean up resources, in the event 'terraform destroy' fails   
- job: 'CleanUp'
  dependsOn:
    - Provision
    - Reprovision
    - Destroy
  displayName: 'Clean Up'
  # Run if Terraform destroy failed, or the whole pipeline was canceled
  condition: or(ne(dependencies.Destroy.result, 'Succeeded'), canceled())
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  variables:
    # Use earlier prepared Terraform config
    terraformClientId: $[ dependencies.Provision.outputs['terraformConfig.clientId'] ]
    terraformClientSecret: $[ dependencies.Provision.outputs['terraformConfig.clientSecret'] ]
    terraformSubscriptionId: $[ dependencies.Provision.outputs['terraformConfig.subscriptionId'] ]
    terraformTenantId: $[ dependencies.Provision.outputs['terraformConfig.tenantId'] ]
    terraformVersion: $[ dependencies.Provision.outputs['terraformConfig.version'] ]

  pool:
    vmImage: 'ubuntu-latest'

  workspace:
    clean: all

  steps:
    - task: AzureResourceGroupDeployment@2
      displayName: 'Tear down IaaS App resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: DeleteRG
        resourceGroupName: '$(iaasResourceGroup)'
      continueOnError: true
      condition: succeededOrFailed()
      enabled: false # rely on tf_clear_state.ps1

    - task: AzureResourceGroupDeployment@2
      displayName: 'Tear down PaaS App resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: DeleteRG
        resourceGroupName: '$(paasResourceGroup)'
      continueOnError: true
      condition: succeededOrFailed()
      enabled: false # rely on tf_clear_state.ps1

    - task: AzureResourceGroupDeployment@2
      displayName: 'Tear down VDC resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: DeleteRG
        resourceGroupName: '$(vdcResourceGroup)'
      continueOnError: true
      condition: succeededOrFailed()
      enabled: false # rely on tf_clear_state.ps1

    - task: TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformVersion)'
      condition: always()

    # Clear Terraform workspace, just in case
    # As a last resort, this also destroys any resources that may not have deleted before
    - task: AzurePowerShell@4
      displayName: 'Clear Terraform workspace'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        ScriptType: 'InlineScript'
        Inline: |
          $(scriptDirectory)/tf_deploy.ps1 -init -trace $(trace)
          $(scriptDirectory)/tf_clear_state.ps1 -destroy -force -wait -timeoutminutes $(jobTimeOutMinutes)
        FailOnStandardError: true
        azurePowerShellVersion: 'LatestVersion'
        pwsh: true
        workingDirectory: '$(scriptDirectory)'
      condition: always()
      env:
        # Use prepared Terraform environment variables
        ARM_CLIENT_ID: '$(terraformClientId)'
        ARM_CLIENT_SECRET: '$(terraformClientSecret)'
        ARM_SUBSCRIPTION_ID: '$(terraformSubscriptionId)'
        ARM_TENANT_ID: '$(terraformTenantId)'
