# This pipeline performans a full CI test of the VDC:
#  - Provision infrastructure
#  - Deploy application
#  - Test application
#  - Destroy infrastructure

trigger:
  branches:
    include:
    - master
  paths:
    include:
    - '*' 
    exclude:
    - 'Apps/*'

pr:
  branches:
    include:
    - '*'

schedules:
  - cron: "0 5 * * *" # UTC
    displayName: Daily early morning build (UTC)
    always: true # Run if there are no changes
    branches:
      include:
      - master

# Global variables shared by all jobs
variables:
  # Variable Groups are referenced, but defined elsewhere (Library)

  # This pipeline assumes ARM_*, TF_VAR_* variables are defined in Variable Groups defined in Library
  # ARM_* environment variables are required by Terraform azurerm provider (both for resources as Terraform backend):
  # https://www.terraform.io/docs/providers/azurerm/index.html
  # https://www.terraform.io/docs/backends/types/azurerm.html
  # These are defined in variable group 'terraform'
- group: 'terraform'

  # The Terraform VDC project requires quite a number of settings, see:
  # https://github.com/geekzter/azure-vdc/blob/master/Terraform/variables.tf
  # https://github.com/geekzter/azure-vdc/blob/master/Terraform/config.auto.tfvars.sample
  # https://github.com/geekzter/azure-vdc/blob/master/Terraform/ci.tfvars
  # i.e. settings in these files should be captured in (a) variable group(s)
  # These can be provided as TF_VAR_<input-variable> environment variables:
  # https://www.terraform.io/docs/configuration/variables.html#environment-variables
  # 'vdc' contains global settings common to all VDC pipelines
- group: 'vdc'
  # 'vdc' contains build (non-release) settings
- group: 'vdc-ci'
  # 'vdc-vanity-domain' contains certificate, domain information
- group: 'vdc-vanity-domain'

# Inline variables shared across jobs
- name: 'agentOS'
  value: 'Linux'
- name: 'agentResourceGroup' 
  value: 'PipelineAgents'
- name: 'scriptDirectory'
  value: '$(Build.SourcesDirectory)/Scripts'


jobs:
- job: 'Prep'
  displayName: 'Start Self-Hosted Agent'

  pool:
    vmImage: 'ubuntu-latest'

  steps:
    # Start the VM that is hosting the agent that will run the rest of the pipeline
    # This VM is prepped by: https://github.com/geekzter/azure-pipeline-agents
    - task: AzureResourceGroupDeployment@2
      displayName: 'Start Self-Hosted Agent(s)'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: 'Start'
        resourceGroupName: '$(agentResourceGroup)'
  
- job: 'Provision'
  dependsOn: 'Prep'
  displayName: 'Provision Infrastructure with Terraform'
  timeoutInMinutes: 120

  pool:
    name: $(agentPool)
    demands:
    - Agent.OS -equals $(agentOS)

  workspace:
    clean: all

  steps:
    - task: DownloadSecureFile@1
      displayName: 'Download SSL certificate'
      inputs:
        secureFile: '$(TF_VAR_vanity_certificate_path)'

    - task: DownloadSecureFile@1
      displayName: 'Download VPN root certificate'
      inputs:
        secureFile: '$(TF_VAR_vpn_root_cert_file)'

    - task: PowerShell@2
      # Name is required so Terraform version number exported by get_tf_version.ps1 can be referenced by subsequent Pipeline steps
      name: TerraformTest
      displayName: 'Get preferred Terraform version number'
      inputs:
        filePath: '$(scriptDirectory)/get_tf_version.ps1'
        arguments: '-version Preferred'
        pwsh: true

    # We could do this with tfenv, however there is no task for that
    - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(TerraformTest.Version)'

    - task: AzurePowerShell@4
      # Name is required so Terraform output exported by tf_deploy.ps1 can be referenced by subsequent Pipeline steps
      name: Terraform 
      displayName: 'Terraform init & apply'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        ScriptType: 'FilePath'
        ScriptPath: '$(scriptDirectory)/tf_deploy.ps1'
        # To start from scratch, use these arguments:
        ScriptArguments: '-init -clear -apply -force -workspace $(workspace) -trace $(trace) -parallelism $(parallelism)'
        # To continue where a previous (broken) build left of, use these arguments:
      # ScriptArguments: '-init -apply -force -stickysuffix -workspace $(workspace) -trace $(trace) -parallelism $(parallelism)'
        FailOnStandardError: true
        azurePowerShellVersion: 'LatestVersion'
        pwsh: true


# Provision again to test for issue's that only come up when resources already exist 
- job: 'Reprovision'
  dependsOn: 'Provision'
  displayName: 'Provision Infrastructure with Terraform (re-entrance test)'
  timeoutInMinutes: 120

  variables:
    # Get resource group names from Terraform output
    iaasResourceGroup: $[ dependencies.Provision.outputs['Terraform.iaas_app_resource_group'] ]
    vdcResourceGroup: $[ dependencies.Provision.outputs['Terraform.vdc_resource_group'] ]
    # Use earlier detected Terraform version
    terraformVersion: $[ dependencies.Provision.outputs['TerraformTest.Version'] ]

  pool:
    name: $(agentPool)
    demands:
    - Agent.OS -equals $(agentOS)

  steps:
    # Assume workspace is empty and re-download secure files
    - task: DownloadSecureFile@1
      displayName: 'Download SSL certificate'
      inputs:
        secureFile: '$(TF_VAR_vanity_certificate_path)'

    - task: DownloadSecureFile@1
      displayName: 'Download VPN root certificate'
      inputs:
        secureFile: '$(TF_VAR_vpn_root_cert_file)'

    - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformVersion)'

    # Deallocate/Stop MV's to force tf_deploy.ps1 to test for stopped VM's
    # Stopped VM's do not allow extensions to be installed
    - task: AzureResourceGroupDeployment@2
      displayName: 'Deallocate VM''s in App resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: StopWithDeallocate
        resourceGroupName: '$(iaasResourceGroup)'

    - task: AzureResourceGroupDeployment@2
      displayName: 'Stop VM''s in VDC resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: Stop
        resourceGroupName: '$(vdcResourceGroup)'

    # Test for failures that only occur when resources already exist
    - task: AzurePowerShell@4
      # Name is required so Terraform output exported by tf_deploy.ps1 can be referenced by subsequent Pipeline steps
      name: Terraform
      displayName: 'Terraform init and apply (re-entrance test)'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        ScriptType: 'FilePath'
        ScriptPath: '$(scriptDirectory)/tf_deploy.ps1'
        ScriptArguments: '-init -apply -force -stickysuffix -workspace $(workspace) -trace $(trace) -parallelism $(parallelism)'
        FailOnStandardError: true
        azurePowerShellVersion: 'LatestVersion'
        pwsh: true


# Deploy PaaS application 
- job: 'Deploy'
  dependsOn: 'Reprovision'
  displayName: 'Deploy & Test PaaS Application'
  timeoutInMinutes: 30

  variables:
    appArtifactDirectory: '$(Pipeline.Workspace)/aspnetcoresql'
    appBuild: 'Release'
    # This references this pipeline:
    # https://github.com/geekzter/dotnetcore-sqldb-tutorial/blob/master/azure-pipelines.yml
    appPipeline: '0b7ba88e-1ad0-4782-839e-850e9a4b53c7'
    appPackage: '$(appArtifactDirectory)/s/bin/$(appBuild)/netcoreapp2.2/publish.zip'
    # Get App Service name & url from Terraform output
    appServiceName: $[ dependencies.Reprovision.outputs['Terraform.paas_app_service_name'] ]
    appUrl: $[ dependencies.Reprovision.outputs['Terraform.paas_app_url'] ]

  pool:
    name: $(agentPool)
    demands:
    - Agent.OS -equals $(agentOS)

  steps:
    # Download PaaS Application Pipeline artifacts
    # This consumes artifacts published by this pipeline:
    # https://github.com/geekzter/dotnetcore-sqldb-tutorial/blob/master/azure-pipelines.yml
    - task: DownloadPipelineArtifact@2
      displayName: 'Download ASP.NET Core App Artifacts'
      inputs:
        buildType: 'specific'
        project: '$(appPipeline)'
        definition: '63'
        specificBuildWithTriggering: true
        buildVersionToDownload: 'latest'
        artifactName: 'aspnetcoresql'
        targetPath: '$(appArtifactDirectory)'

    - task: PowerShell@2
      displayName: 'List ASP.NET Core App Artifacts'
      enabled: false # Used for debug only, e.g. if the publish.zip package got moved
      inputs:
        targetType: 'inline'
        script: 'Get-ChildItem . -Recurse | Select-Object FullName'
        errorActionPreference: 'continue'
        pwsh: true
        workingDirectory: '$(appArtifactDirectory)'

    # Deploy PaaS Application
    - task: AzureWebApp@1
      displayName: 'Deploy ASP.NET Core App'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        appType: webApp
        appName: '$(appServiceName)'
        package: '$(appPackage)'

    # Test PaaS Application
    - task: PowerShell@2
      displayName: 'Test ASP.NET Core App'
      inputs:
        targetType: 'inline'
        script: |
          # Wait for the WAF to get ready
          Start-Sleep -Seconds 30
          
          # Request page
          Invoke-WebRequest $(appUrl)
        failOnStderr: true
        pwsh: true


# Destroy infrastructure
- job: 'Destroy'
  dependsOn:
    - Deploy
    - Provision
  displayName: 'Destroy Infrastructure with Terraform'
  timeoutInMinutes: 120

  variables:
    # Use earlier detected Terraform version
    terraformVersion: $[ dependencies.Provision.outputs['TerraformTest.Version'] ]

  pool:
    name: $(agentPool)
    demands:
    - Agent.OS -equals $(agentOS)

  steps:
    - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformVersion)'

    # Terraform will destroy all resources it created, using its backend state
    - task: AzurePowerShell@4
      displayName: 'Terraform destroy'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        ScriptPath: '$(scriptDirectory)/tf_deploy.ps1'
        ScriptArguments: '-init -destroy -force -workspace $(workspace) -trace $(trace) -parallelism $(parallelism)'
        FailOnStandardError: true
        azurePowerShellVersion: LatestVersion
        pwsh: true
      condition: succeededOrFailed()
      enabled: true

    # When using tfenv, this will make sure the same Terraform version will be used as we tested in this pipeline
    - task: PowerShell@2
      displayName: 'Save used Terraform version number with tfenv'
      inputs:
        targetType: filePath
        filePath: '$(scriptDirectory)/get_tf_version.ps1'
        arguments: ' -version installed | Out-File $(Build.SourcesDirectory)/Terraform/.terraform-version'
        pwsh: true

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Initialized Terraform workspace (with tested version of providers)'
      inputs:
        artifact: drop


# Clean up resources        
- job: 'CleanUp'
  dependsOn:
    - Provision
    - Destroy
  displayName: 'Clean Up'
  condition: failed()
# condition: eq(1,2) # Disable job
  timeoutInMinutes: 120

  variables:
    # Get resource group names from Terraform output
    iaasResourceGroup: $[ dependencies.Provision.outputs['Terraform.iaas_app_resource_group'] ]
    paasResourceGroup: $[ dependencies.Provision.outputs['Terraform.paas_app_resource_group'] ]
    vdcResourceGroup: $[ dependencies.Provision.outputs['Terraform.vdc_resource_group'] ]
    # Use earlier detected Terraform version
    terraformVersion: $[ dependencies.Provision.outputs['TerraformTest.Version'] ]

  pool:
    name: $(agentPool)
    demands:
    - Agent.OS -equals $(agentOS)

  workspace:
    clean: all

  steps:
    - task: AzureResourceGroupDeployment@2
      displayName: 'Tear down IaaS App resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: DeleteRG
        resourceGroupName: '$(iaasResourceGroup)'
      continueOnError: true
      condition: always()

    - task: AzureResourceGroupDeployment@2
      displayName: 'Tear down PaaS App resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: DeleteRG
        resourceGroupName: '$(paasResourceGroup)'
      continueOnError: true
      condition: always()

    - task: AzureResourceGroupDeployment@2
      displayName: 'Tear down VDC resource group'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        action: DeleteRG
        resourceGroupName: '$(vdcResourceGroup)'
      continueOnError: true
      condition: always()

    - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformVersion)'

    # Clear Terraform workspace, just in case
    # This also destroys any resources that may not have deleted before
    - task: AzurePowerShell@4
      displayName: 'Clear Terraform workspace'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        ScriptPath: '$(scriptDirectory)/tf_clear_state.ps1'
        ScriptArguments: '-workspace $(workspace) -destroy -force'
        FailOnStandardError: true
        azurePowerShellVersion: LatestVersion
        pwsh: true
      condition: always()
