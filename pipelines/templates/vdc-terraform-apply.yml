# This pipeline performs a full CI test of the VDC:
#  - Provision infrastructure
#  - Deploy application
#  - Test application
#  - Destroy infrastructure

parameters:
- name: name
  displayName: Stage Name
  type: string
- name: displayName
  displayName: Stage Display Name
  type: string
- name: inherit
  displayName: Inherit state
  type: boolean
  default: false
- name: provision
  displayName: Provision infrastructure
  type: boolean
  default: true
- name: reprovision
  displayName: Provision infrastructure
  type: boolean
  default: true
- name: deploy
  displayName: Deploy applications
  type: boolean
  default: true
- name: deployIaaS
  displayName: Deploy IaaS application
  type: boolean
  default: true
- name: destroy
  displayName: Destroy infrastructure
  type: string
  default: Always
  values:
  - Always
  - Never 
  - 'On failure'
  - 'On success'
- name: workspace
  displayName: Pipeline Environment / Terraform Workspace
  type: string
  default: ci
  values:
  - ci
  - ci1
  - ci2
  - ci3
  - cd1
  - cd2
  - cd3
  - rel
  - rel1
  - rel2
  - rel3
  - test
  - tst1
  - tst2
  - tst3
- name: deploymentName
  displayName: Deployment name (middle part resource names)
  type: string
  default: ''
- name: resourceSuffix
  displayName: Deployment name (middle part resource names)
  type: string
  default: ''
- name: unpinTerraform
  displayName: Unpin Terraform version
  type: boolean
  default: false
- name: unpinTerraformProviders
  displayName: Unpin Terraform provider versions
  type: boolean
  default: false
- name: vdcArtifactPipeline
  displayName: Pipeline (alias) for artifacts
  type: string
  default: ''
- name: testMode
  displayName: Test Mode (disable most tasks)
  type: boolean
  default: false

stages:
- stage: ${{ parameters.name }}
  displayName: ${{ parameters.displayName }}

  # Global variables shared by all jobs
  variables:
  - name: 'agentTag'
    value: 'web'
  - name: 'vdcArtifactName'
    value: 'drop'
  - name: 'TF_WORKSPACE'
    value: ${{ parameters.workspace }}
  - name: 'scriptDirectory'
    ${{ if eq(length(parameters.vdcArtifactPipeline),0) }}:
      value: '$(Build.SourcesDirectory)/scripts'
    ${{ if and(gt(length(parameters.vdcArtifactPipeline),0),ne(parameters.vdcArtifactPipeline,'current')) }}:
      value: '$(Pipeline.Workspace)/${{parameters.vdcArtifactPipeline}}/$(vdcArtifactName)/s/scripts'
    ${{ if eq(parameters.vdcArtifactPipeline,'current') }}:
      value: '$(Pipeline.Workspace)/$(vdcArtifactName)/s/scripts'
  - name: 'terraformDirectory'
    ${{ if eq(length(parameters.vdcArtifactPipeline),0) }}:
      value: '$(Build.SourcesDirectory)/terraform'
    ${{ if and(gt(length(parameters.vdcArtifactPipeline),0),ne(parameters.vdcArtifactPipeline,'current')) }}:
      value: '$(Pipeline.Workspace)/${{parameters.vdcArtifactPipeline}}/$(vdcArtifactName)/s/terraform'
    ${{ if eq(parameters.vdcArtifactPipeline,'current') }}:
      value: '$(Pipeline.Workspace)/$(vdcArtifactName)/s/terraform'
  - name: 'TF_VAR_deployment_name'
    ${{ if eq(length(parameters.deploymentName),0) }}:
      value: ${{ parameters.workspace }}
    ${{ if gt(length(parameters.deploymentName),0) }}:
      value: ${{ parameters.deploymentName }}
  - ${{ if gt(length(parameters.resourceSuffix),0) }}:
    - name: 'TF_VAR_resource_suffix'
      value: ${{ parameters.resourceSuffix }}
  - name: 'iaasResourceGroup'
    value: '$(TF_VAR_resource_prefix)-$(TF_VAR_deployment_name)-iaasapp-$(TF_VAR_resource_suffix)'
  - name: 'paasResourceGroup'
    value: '$(TF_VAR_resource_prefix)-$(TF_VAR_deployment_name)-paasapp-$(TF_VAR_resource_suffix)'
  - name: 'vdcResourceGroup' 
    value: '$(TF_VAR_resource_prefix)-$(TF_VAR_deployment_name)-$(TF_VAR_resource_suffix)'
  - name: 'terraformVersionRequest'
    ${{ if parameters.unpinTerraform }}:
      value: 'latest'
    ${{ if not(parameters.unpinTerraform) }}:
      value: 'preferred'
  - name: cleanUpOnCancel
    ${{ if eq(parameters.destroy, 'Always') }}:
      value: true
    ${{ if eq(parameters.destroy, 'Never') }}:
      value: false
    ${{ if eq(parameters.destroy, 'On failure') }}:
      value: true
    ${{ if eq(parameters.destroy, 'On success') }}:
      value: false

  jobs:
  - job: 'Prepare'
    displayName: 'Prepare'
    condition: succeeded()
    timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

    pool:
      vmImage: 'ubuntu-latest'

    workspace:
      clean: all

    steps:
      - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
        - download: ${{parameters.vdcArtifactPipeline}}
          artifact: $(vdcArtifactName)
  
      - pwsh: |
          Write-Host "Script Directory: $(scriptDirectory)"
          Write-Host "Workspace Contents:"
          Get-ChildItem $(Pipeline.Workspace) -Recurse
          Write-Host "Environment:"
          Get-ChildItem -Path Env:* | Sort-Object -Property Name
        displayName: 'Test task'
        enabled: ${{ parameters.testMode }}
      - task: AzureCLI@2
        displayName: 'Gather Terraform settings'
        enabled: ${{ not(parameters.testMode) }}
        name: terraformConfig
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            # List environment variables
            Get-ChildItem -Path Env: -Recurse -Include ARM_*,TF_* | Sort-Object -Property Name

            # This will write version info as output variable
            $(scriptDirectory)/get_tf_version.ps1 -version $(terraformVersionRequest)
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(scriptDirectory)'

  - ${{ if or(eq(parameters.provision, true),eq(parameters.reprovision, true),eq(parameters.deploy, true),eq(parameters.deployIaaS, true)) }}:
    # Creates an environment if it doesn't exist yet
    - deployment: CreateEnvironment
      displayName: Create Environment (if it does not exist yet)
      pool:
        vmImage: 'ubuntu-latest'
      environment: '${{ parameters.workspace }}'
      strategy:
        runOnce:
          deploy:
            steps:
            - script: echo Environment ${{ parameters.workspace }} exists
              displayName: 'Create environment ${{ parameters.workspace }}'

  - ${{ if or(eq(parameters.provision, true),eq(parameters.reprovision, true),eq(parameters.deploy, true),eq(parameters.deployIaaS, true)) }}:
    # Provision on self-hosted agent
    - job: 'Provision'
      dependsOn: 
      - Prepare
      - CreateEnvironment
      displayName: 'Provision Infrastructure with Terraform'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: 'ubuntu-latest'

      workspace:
        clean: all

      steps:
        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - download: ${{parameters.vdcArtifactPipeline}}
            artifact: $(vdcArtifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: DownloadSecureFile@1
          displayName: 'Download SSL certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vanity_certificate_path)'

        - task: DownloadSecureFile@1
          displayName: 'Download SSL root certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vanity_root_certificate_cer_path)'
  
        - task: DownloadSecureFile@1
          displayName: 'Download VPN root certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vpn_root_cert_file)'

        # We could do this with tfenv, however there is no task for that
        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.vdcArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              #(Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              (Get-Content ./provider.tf) -replace "version *= `" *= +",'version = "~> ' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        - task: AzureCLI@2
          # Name is required so Terraform output exported by tf_deploy.ps1 can be referenced by subsequent Pipeline steps
          name: terraform
          displayName: 'Terraform init & apply'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              $(scriptDirectory)/tf_deploy.ps1 -init -clear:$${{ not(parameters.inherit) }} -stickysuffix:$${{ parameters.inherit }} -apply -force -trace $(trace) -parallelism $(parallelism)
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(scriptDirectory)'
          env:
            TF_VAR_default_delete_timeout: '$(jobTimeOutMinutes)m'
            TF_VAR_default_create_timeout: '$(jobTimeOutMinutes)m'
            TF_VAR_default_update_timeout: '$(jobTimeOutMinutes)m'

  - ${{ if eq(parameters.reprovision, true) }}:
    # Provision again to test for issue's that only come up when resources already exist 
    - job: 'Reprovision'
      dependsOn:
      - Prepare
      - Provision
      displayName: 'Provision Infrastructure with Terraform (re-entrance test)'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        iaasResourceGroup: $[ dependencies.Provision.outputs['terraform.iaas_app_resource_group'] ]
        vdcResourceGroup: $[ dependencies.Provision.outputs['terraform.vdc_resource_group'] ]
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: 'ubuntu-latest'

      steps:
        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - download: ${{parameters.vdcArtifactPipeline}}
            artifact: $(vdcArtifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Assume workspace is empty and re-download secure files
        - task: DownloadSecureFile@1
          displayName: 'Download SSL certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vanity_certificate_path)'

        - task: DownloadSecureFile@1
          displayName: 'Download SSL root certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vanity_root_certificate_cer_path)'
  
        - task: DownloadSecureFile@1
          displayName: 'Download VPN root certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vpn_root_cert_file)'

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.vdcArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +",'version = "~> ' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        # Deallocate/Stop MV's to force tf_deploy.ps1 to test for stopped VM's
        # Stopped VM's do not allow extensions to be installed
        - task: AzureResourceGroupDeployment@2
          displayName: 'Stop VM''s in VDC resource group'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: Stop
            resourceGroupName: '$(vdcResourceGroup)'

        - task: AzureResourceGroupDeployment@2
          displayName: 'Deallocate VM''s in App resource group'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: StopWithDeallocate
            resourceGroupName: '$(iaasResourceGroup)'

        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        # Test for failures that only occur when resources already exist
        - task: AzureCLI@2
          name: terraform
          displayName: 'Terraform init and apply (re-entrance test)'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              $(scriptDirectory)/tf_deploy.ps1 -init -apply -force -stickysuffix -trace $(trace) -parallelism $(parallelism)
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(scriptDirectory)'
          env:
            TF_VAR_default_create_timeout: '$(jobTimeOutMinutes)m'

  - ${{ if eq(parameters.deploy, true) }}:
    # Deploy PaaS application 
    - job: 'Deploy'
      dependsOn:
        - Prepare
        - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Deploy PaaS Application'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        appArtifactDirectory: '$(Pipeline.Workspace)/aspnetcoresql'
        appBuild: 'Release'
        appPackage: '$(appArtifactDirectory)/s/bin/$(appBuild)/netcoreapp3.1/publish.zip'
        # Get application configuration from Terraform output
        appServiceName: $[ dependencies.Provision.outputs['terraform.paas_app_service_name'] ]
        appMSIName: $[ dependencies.Provision.outputs['terraform.paas_app_service_msi_name'] ]
        appMSIClientID: $[ dependencies.Provision.outputs['terraform.paas_app_service_msi_client_id'] ]
        appSQLAdmin: 'vdcadmin'
        appSQLDatabase: $[ dependencies.Provision.outputs['terraform.paas_app_sql_database'] ]
        appSQLFirewallImportRule: 'AllowAllWindowsAzureIPs'
        appSQLServer: $[ dependencies.Provision.outputs['terraform.paas_app_sql_server'] ]
        appSQLServerFQDN: $[ dependencies.Provision.outputs['terraform.paas_app_sql_server_fqdn'] ]
        appURL: $[ dependencies.Provision.outputs['terraform.paas_app_url'] ]
        devOpsOrgURL: $[ dependencies.Provision.outputs['terraform.devops_org_url'] ]
        devOpsProject: $[ dependencies.Provision.outputs['terraform.devops_project'] ]
        dbaName: $[ dependencies.Provision.outputs['terraform.admin_login'] ]
        dbaObjectID: $[ dependencies.Provision.outputs['terraform.admin_object_id'] ]
        paasResourceGroup: $[ dependencies.Provision.outputs['terraform.paas_app_resource_group'] ]
        storageUrl: 'https://ewimages.blob.core.windows.net/databasetemplates/vdcdevpaasappsqldb-2020-1-18-15-13.bacpac'
        storageSAS: '?st=2020-03-20T13%3A57%3A32Z&se=2023-04-12T13%3A57%3A00Z&sp=r&sv=2018-03-28&sr=c&sig=qGpAjJlpDQsq2SB6ev27VbwOtgCwh2qu2l3G8kYX4rU%3D'
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        # SqlAzureDacpacDeployment@1 only runs on Windows
        vmImage: 'ubuntu-latest'

      steps:
        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - download: ${{parameters.vdcArtifactPipeline}}
            artifact: $(vdcArtifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Assume workspace is empty and re-download secure files
        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.vdcArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - task: AzureCLI@2
          name: terraformConfig
          displayName: 'Terraform init'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,TF_* | Sort-Object -Property Name
              $(scriptDirectory)/tf_deploy.ps1 -init 
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(scriptDirectory)'
          env:
            TF_VAR_default_delete_timeout: '$(jobTimeOutMinutes)m'

        - pwsh: |
            Invoke-Webrequest -Uri "$(storageUrl)$(storageSAS)" -OutFile $(System.DefaultWorkingDirectory)/database.bacpac
          displayName: 'Download BACPAC'
          enabled: false

        - task: SqlAzureDacpacDeployment@1 
        # https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/sql-azure-dacpac-deployment
          displayName: 'Import database'
          enabled: false
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            authenticationType: aadAuthenticationIntegrated
            serverName: $(appSQLServerFQDN)
            databaseName: $(appSQLDatabase)
            deploymentAction: Import
            bacpacFile: '$(System.DefaultWorkingDirectory)/database.bacpac'
            ipDetectionMethod: 'AutoDetect'
            deleteFirewallRule: true

        - task: AzureCLI@2
          displayName: 'Import database, set permissions (with script) & swap App Service slots'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)
              $(scriptDirectory)/punch_hole.ps1 -UsePreviewApis
              cd $(scriptDirectory)
              $(scriptDirectory)/deploy_paas_app.ps1 -All `
                                    -AppResourceGroup $(paasResourceGroup) `
                                    -AppAppServiceName $(appServiceName) `
                                    -AppAppServiceIdentity $(appMSIName) `
                                    -AppAppServiceClientID $(appMSIClientID) `
                                    -DBAName $(dbaName) `
                                    -DBAObjectId $(dbaObjectId) `
                                    -AppUrl $(appURL) `
                                    -DevOpsOrgUrl $(devOpsOrgURL) `
                                    -DevOpsProject $(devOpsProject) `
                                    -SqlServer $(appSQLServer) `
                                    -SqlServerFQDN $(appSQLServerFQDN) `
                                    -SqlDatabase $(appSQLDatabase)
            addSpnToEnvironment: true
            useGlobalConfig: true
            workingDirectory: '$(terraformDirectory)'
            failOnStandardError: true

  - ${{ if eq(parameters.deployIaaS, true) }}:
    # First things first, we need to check whether the environment is ready to deploy to
    - job: 'DeployEnvironmentPrep'
      dependsOn:
        - Prepare
        - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Prepare Environment'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        iaasResourceGroup: $[ dependencies.Provision.outputs['terraform.iaas_app_resource_group'] ]
        resourceSuffix:  $[ dependencies.Provision.outputs['terraform.resource_suffix'] ]
        timeOutSeconds: 1200

      pool:
        # SqlAzureDacpacDeployment@1 only runs on Windows
        vmImage: 'ubuntu-latest'

      steps:
        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - download: ${{parameters.vdcArtifactPipeline}}
            artifact: $(vdcArtifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # If applications are deployed, wait for environment agents to come online
        # Requires Project Collection Build Service reader access to Environment
        - task: AzureCLI@2
          name: waitforagents
          displayName: 'Wait for environment agents to come online'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $global:InformationPreference = "Continue"
              $global:VerbosePreference = "Continue"
              #$(scriptDirectory)/wait_for_agents.ps1 -ResourceGroup $(iaasResourceGroup) -TimeoutSeconds $(timeOutSeconds)
              $(scriptDirectory)/wait_for_agents.ps1 -Environment ${{ parameters.workspace }} -OrganizationUrl $(System.TeamFoundationCollectionUri) -Project $(System.TeamProject) -Tags $(agentTag),$(resourceSuffix) -TimeoutSeconds $(timeOutSeconds)
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(scriptDirectory)'
          env:
            # Use Pipeline token to access Azure DevOps
            AZURE_DEVOPS_EXT_PAT: '$(System.AccessToken)'

  - ${{ if eq(parameters.deployIaaS, true) }}:
    - deployment: 'DeployEnvironment'
      dependsOn:
        - Prepare
        - Provision
        - DeployEnvironmentPrep
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Deploy IaaS Application'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        appArtifactDirectory: '$(Pipeline.Workspace)/aspnet'
        appScriptsDirectory: '$(Pipeline.Workspace)/aspnetscripts'
        appPackage: '$(appArtifactDirectory)/SampleIisWebApp.zip'
        resourceSuffix: $[ dependencies.Provision.outputs['terraform.resource_suffix'] ]

      ${{ if eq(parameters.testMode, true) }}:
        pool:
          vmImage: 'ubuntu-latest'      

      ${{ if eq(parameters.testMode, true) }}:
        environment:
          name: '${{ parameters.workspace }}'

      ${{ if eq(parameters.testMode, false) }}:
        environment:
          name: '${{ parameters.workspace }}'
          resourceType: virtualMachine
          # BUG: Only literals are allowed
          # https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema%2Cparameter-schema#environment
          # tags: string | [ string ] # tag names to filter the resources in the environment
          # tags: $(agentTag) $(resourceSuffix)
          tags: web

      strategy:
        runOnce:
          deploy:
            steps:
            - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
              - download: ${{parameters.vdcArtifactPipeline}}
                artifact: $(vdcArtifactName)
    
            - pwsh: |
                Write-Host "Hello Task"
                Write-Host "Tags: $(agentTag), $(resourceSuffix)"
              displayName: 'Test task'
              enabled: ${{ parameters.testMode }}

            # Download IaaS Application Pipeline artifacts
            # This consumes artifacts published by this pipeline:
            # https://github.com/geekzter/azure-vdc/blob/master/pipelines/iis-asp.net-ci.yml
            - task: DownloadPipelineArtifact@2
              displayName: 'Download ASP.NET Core App Artifacts'
              enabled: ${{ not(parameters.testMode) }}
              inputs:
                buildType: 'specific'
                project: '$(appArtifectProject)'
                definition: '$(appBuildDefinitionIaaS)'
                specificBuildWithTriggering: true
                buildVersionToDownload: 'latest'
                artifactName: 'aspnet'
                downloadPath: '$(appArtifactDirectory)'
            - task: DownloadBuildArtifacts@0
              displayName: 'Download ASP.NET Core App Artifacts'
              enabled: false
              inputs:
                buildType: 'specific'
                project: '$(appArtifectProject)'
                definition: '$(appBuildDefinitionIaaS)'
                specificBuildWithTriggering: true
                buildVersionToDownload: 'latest'
                artifactName: 'aspnet'
                downloadPath: '$(appArtifactDirectory)'
            - task: DownloadPipelineArtifact@2
              displayName: 'Download Scripts'
              enabled: ${{ not(parameters.testMode) }}
              inputs:
                buildType: 'specific'
                project: '$(appArtifectProject)'
                definition: '$(appBuildDefinitionIaaS)'
                specificBuildWithTriggering: true
                buildVersionToDownload: 'latest'
                artifactName: 'aspnetscripts'
                downloadPath: '$(appScriptsDirectory)'
            - task: DownloadBuildArtifacts@0
              displayName: 'Download Scripts'
              enabled: false
              inputs:
                buildType: 'specific'
                project: '$(appArtifectProject)'
                definition: '$(appBuildDefinitionIaaS)'
                specificBuildWithTriggering: true
                buildVersionToDownload: 'latest'
                artifactName: 'aspnetscripts'
                downloadPath: '$(appScriptsDirectory)'

            # Configure IIS on VM's
            - task: IISWebAppManagementOnMachineGroup@0
              displayName: 'Configure IIS App'
              enabled: ${{ not(parameters.testMode) }}
              inputs:
                EnableIIS: true
                WebsiteName: 'Default Web Site'
                AddBinding: true
                Bindings: '{"bindings":[{"protocol":"http","ipAddress":"All Unassigned","port":"80","hostname":"","sslThumbprint":"","sniFlag":false}]}'
                CreateOrUpdateAppPoolForWebsite: true
                AppPoolNameForWebsite: DemoAppPool
                AppCmdCommands: |
                  start apppool /apppool.name:DemoAppPool
                  set config /section:defaultDocument "/~files" 
                  set config /section:defaultDocument "/+files.[@start,value='default.aspx']"          

            - task: IISWebAppDeploymentOnMachineGroup@0
              displayName: 'Deploy IIS App'
              enabled: ${{ not(parameters.testMode) }}
              inputs:
                WebSiteName: 'Default Web Site'
                Package: '$(appPackage)'
                TakeAppOfflineFlag: true

            - powershell: |
                Invoke-WebRequest -Uri http://127.0.0.1/default.aspx -UseBasicParsing
              errorActionPreference: continue
              displayName: 'Initial Warmup'
              enabled: false

            - task: CopyFiles@2
              displayName: 'Copy Warmup Scripts'
              enabled: ${{ not(parameters.testMode) }}
              inputs:
                SourceFolder: '$(appScriptsDirectory)'
                TargetFolder: 'C:\Users\Public\Documents'

            - task: BatchScript@1
              displayName: 'Schedule Warmup Scripts'
              enabled: ${{ not(parameters.testMode) }}
              inputs:
                filename: '$(appScriptsDirectory)/schedule-warmup.cmd'

  - ${{ if eq(parameters.deploy, true) }}:
    # Test applications
    - job: 'Test'
      dependsOn:
        - Deploy
        - ${{ if eq(parameters.deployIaaS, true) }}:
          - DeployEnvironment
        - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Test Applications'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        apimGWUrl:     $[ dependencies.Provision.outputs['terraform.apim_gateway_url'] ]
        apimPortalUrl: $[ dependencies.Provision.outputs['terraform.apim_developer_portal_url'] ]
        deployAPIM:    $[ eq(variables['TF_VAR_deploy_api_gateway'], 'true') ]
        iaasAppUrl:    $[ dependencies.Provision.outputs['terraform.iaas_app_url'] ]
        paasAppUrl:    $[ dependencies.Provision.outputs['terraform.paas_app_url'] ]
        # apim_demo_api_key get's updated on every terraform apply, make sure we get up to date data
        ${{ if eq(parameters.reprovision, false) }}:
          apimDemoKey: $[ dependencies.Provision.outputs['terraform.apim_demo_api_key'] ]
        ${{ if eq(parameters.reprovision, true) }}:
          apimDemoKey: $[ dependencies.Reprovision.outputs['terraform.apim_demo_api_key'] ]

      pool:
        vmImage: 'ubuntu-latest'

      steps:
        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - download: ${{parameters.vdcArtifactPipeline}}
            artifact: $(vdcArtifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Test IaaS Application
        - task: PowerShell@2
          displayName: 'Test IaaS Application'
          enabled: ${{ and(not(parameters.testMode),parameters.deployIaaS) }}
          inputs:
            targetType: 'inline'
            script: |
              # Wait for the WAF to get ready
              Start-Sleep -Seconds 10
              
              # Request page
              Write-Host "Requesting $(iaasAppUrl)..."
              Invoke-WebRequest -Uri $(iaasAppUrl) -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true

        # Test PaaS Application
        - task: PowerShell@2
          displayName: 'Test PaaS Application'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              # Wait for the WAF to get ready
              Start-Sleep -Seconds 10
              
              # Request page
              Write-Host "Requesting $(paasAppUrl)..."
              Invoke-WebRequest -Uri $(paasAppUrl) -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true

        # Test API Management
        - task: PowerShell@2
          displayName: 'Test API Management Portal'
          condition: and(succeeded(), eq(variables.deployAPIM, true))
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              # Request page
              Write-Host "Requesting $(apimPortalUrl)..."
              Invoke-WebRequest -Uri $(apimPortalUrl) -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true
        - task: PowerShell@2
          displayName: 'Test API Management Gateway'
          condition: and(succeeded(), eq(variables.deployAPIM, true))
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              # Call REST Api
              $apimDemoUrl = "$(apimGWUrl)echo/resource?param1=sample"
              Write-Host "Performing GET request of $apimDemoUrl with Header Ocp-Apim-Subscription-Key = $(apimDemoKey)..."
              Invoke-RestMethod -Header @{ "Ocp-Apim-Subscription-Key" = "$(apimDemoKey)" } -Method Get -Uri $apimDemoUrl -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true

  - ${{ if ne(parameters.destroy, 'Never') }}:
    # Destroy infrastructure
    - job: 'Destroy'
      dependsOn:
        - Prepare
        - ${{ if or(eq(parameters.provision, true),eq(parameters.deploy, true)) }}:
          - Provision
        - ${{ if eq(parameters.deployIaaS, true) }}:
          - DeployEnvironment
        - ${{ if eq(parameters.deploy, true) }}:
          - Deploy
          - Test
      displayName: 'Destroy Infrastructure with Terraform'

      ${{ if eq(parameters.destroy, 'Always') }}:
        condition: succeededOrFailed()
      ${{ if eq(parameters.destroy, 'On failure') }}:
        condition: failed()
      ${{ if eq(parameters.destroy, 'On success') }}:
        condition: succeeded()

      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: 'ubuntu-latest'

      steps:
        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - download: ${{parameters.vdcArtifactPipeline}}
            artifact: $(vdcArtifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Assume workspace is empty and re-download secure files
        - task: DownloadSecureFile@1
          displayName: 'Download SSL certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vanity_certificate_path)'

        - task: DownloadSecureFile@1
          displayName: 'Download SSL root certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vanity_root_certificate_cer_path)'
  
        - task: DownloadSecureFile@1
          displayName: 'Download VPN root certificate'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            secureFile: '$(TF_VAR_vpn_root_cert_file)'
            
        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.vdcArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        - task: AzureCLI@2
          name: terraformConfig
          displayName: 'Terraform destroy'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              $(scriptDirectory)/tf_deploy.ps1 -init -destroy -force -trace $(trace) -parallelism $(parallelism)
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(scriptDirectory)'
          env:
            TF_VAR_default_delete_timeout: '$(jobTimeOutMinutes)m'

        # When using tfenv, this will make sure the same Terraform version will be used as we tested in this pipeline
        - task: PowerShell@2
          displayName: 'Save used Terraform version number with tfenv'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            targetType: filePath
            filePath: '$(scriptDirectory)/get_tf_version.ps1'
            arguments: ' -version installed | Out-File $(terraformDirectory)/.terraform-version'
            pwsh: true
            workingDirectory: '$(scriptDirectory)'

        - ${{ if eq(length(parameters.vdcArtifactPipeline),0) }}:
        # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
        # Publish Initialized Terraform workspace
        # This workspace can be downloaded as artifacts in a release pipeline. 
        # That release pipeline will than run with tested versions of Terraform and Terraform providers, without the need for 'terraform init'
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Initialized Terraform workspace'
          # enabled: ${{ not(parameters.testMode) }}
            inputs:
              artifact: $(vdcArtifactName)

  - ${{ if ne(parameters.destroy, 'Never') }}:
    # Clean up resources, in the event 'terraform destroy' fails   
    - job: 'CleanUp'
      dependsOn:
        - Prepare
        - Destroy
        - ${{ if or(eq(parameters.provision, true),eq(parameters.deploy, true)) }}:
          - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Clean Up'
      # Run if Terraform destroy failed, or the whole pipeline was canceled
      condition: or(and(ne(dependencies.Destroy.result, 'None'),ne(dependencies.Destroy.result, 'Skipped'),ne(dependencies.Destroy.result, 'Succeeded')), and(canceled(),variables.cleanUpOnCancel))
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: 'ubuntu-latest'

      workspace:
        clean: all

      steps:
        - ${{ if gt(length(parameters.vdcArtifactPipeline),0) }}:
          - download: ${{parameters.vdcArtifactPipeline}}
            artifact: $(vdcArtifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: AzureResourceGroupDeployment@2
          displayName: 'Tear down IaaS App resource group'
          enabled: false # rely on erase.ps1
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: DeleteRG
            resourceGroupName: '$(iaasResourceGroup)'
          continueOnError: true
          condition: succeededOrFailed()

        - task: AzureResourceGroupDeployment@2
          displayName: 'Tear down PaaS App resource group'
          enabled: false # rely on erase.ps1
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: DeleteRG
            resourceGroupName: '$(paasResourceGroup)'
          continueOnError: true
          condition: succeededOrFailed()

        - task: AzureResourceGroupDeployment@2
          displayName: 'Tear down VDC resource group'
          enabled: false # rely on erase.ps1
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: DeleteRG
            resourceGroupName: '$(vdcResourceGroup)'
          continueOnError: true
          condition: succeededOrFailed()

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'
          condition: always()

        # Clear Terraform workspace, just in case
        # As a last resort, this also destroys any resources that may not have deleted before
        - task: AzureCLI@2
          name: terraform
          displayName: 'Clear Terraform workspace'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              $(scriptDirectory)/tf_deploy.ps1 -init -trace $(trace)
              $(scriptDirectory)/erase.ps1 -destroy -force -wait -timeoutminutes $(jobTimeOutMinutes)
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellErrorActionPreference: 'Continue'
            powerShellIgnoreLASTEXITCODE: true
            workingDirectory: '$(scriptDirectory)'
            